diff -u connector/plc4x.go.orig connector/plc4x.go
--- connector/plc4x.go.orig	2021-03-05 23:43:20.000000000 +0100
+++ connector/plc4x.go	2021-03-05 23:43:20.000000000 +0100
@@ -2,9 +2,9 @@
 
 import (
 	"context"
+	"encoding/json"
 	"log"
 	"time"
-	"encoding/json"
 
 	"github.com/nutanix/kps-connector-go-sdk/transport"
 
@@ -12,7 +12,6 @@
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/drivers"
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/model"
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/transports"
-
 )
 
 type Address struct {
@@ -20,17 +19,15 @@
 	Address string
 }
 
-type rvalue struct{
+type rvalue struct {
 	Field []string `json:"field"`
 	Value []string `json:"value"`
 }
 
-
 type streamMetadata struct {
 	Plc       string
 	Addresses []Address
 
-	
 	//PollingIntervall int  // removed for testing
 }
 
@@ -57,26 +54,25 @@
 			// bail out
 		}
 		log.Printf("add Address: %s", addressAddress)
-		
+
 		addr := Address{
-			Name: addressName,
+			Name:    addressName,
 			Address: addressAddress,
 		}
 		addresses = append(addresses, addr)
 	}
 
-
 	return &streamMetadata{
-		Plc: plc,
-		Addresses: addresses,		
+		Plc:       plc,
+		Addresses: addresses,
 	}
 }
 
 type consumer struct {
 	transport  transport.Client
 	metadata   *streamMetadata
-	connection *plc4go.PlcConnection    //?????
-	rr         model.PlcReadRequest // ???? ReadRequest}
+	connection *plc4go.PlcConnection //?????
+	rr         model.PlcReadRequest  // ???? ReadRequest}
 }
 
 // producer consumes the data from the relevant client or service and publishes them to KPS data pipelines
@@ -89,10 +85,8 @@
 // from the relevant client or service
 func (c *consumer) nextMsg() ([]byte, error) {
 
-
-
 	// manual slow down Polling
-	time.Sleep(5 * time.Second )
+	time.Sleep(5 * time.Second)
 	rrc := c.rr.Execute()
 	log.Printf("nexmsg")
 	// Wait for the response to finish
@@ -103,28 +97,28 @@
 	}
 
 	// Do something with the response
-	
-	rvalues := make([]string,0)
-	rfields := make([]string,0)
-	
+
+	rvalues := make([]string, 0)
+	rfields := make([]string, 0)
+
 	for _, fieldname := range rrr.Response.GetFieldNames() {
 		log.Printf("processing field: %s", fieldname)
 		if rrr.Response.GetResponseCode(fieldname) != model.PlcResponseCode_OK {
 			log.Printf("error an non-ok return code: %s", rrr.Response.GetResponseCode(fieldname).GetName())
 			return nil, nil
 		}
-	
+
 		value := rrr.Response.GetValue(fieldname)
 		log.Printf("Returned Value: %s", value.GetString())
-		rfields = append(rfields,fieldname)
-		rvalues = append(rvalues,value.GetString())
+		rfields = append(rfields, fieldname)
+		rvalues = append(rvalues, value.GetString())
 	}
-	
+
 	toMarshal := &rvalue{
 		Field: rfields,
 		Value: rvalues,
 	}
-	
+
 	return json.Marshal(toMarshal)
 }
 
@@ -138,7 +132,7 @@
 
 	// Get a connection to a remote PLC
 	crc := driverManager.GetConnection(metadata.Plc)
-	 // Wait for the driver to connect (or not)
+	// Wait for the driver to connect (or not)
 	connectionResult := <-crc
 	if connectionResult.Err != nil {
 		log.Printf("error connecting to PLC: %s", connectionResult.Err.Error())
@@ -157,7 +151,7 @@
 		log.Printf("added address: %s", address.Address)
 		rrb.AddItem(address.Name, address.Address)
 	}
-	
+
 	readRequest, err := rrb.Build()
 	if err != nil {
 		log.Printf("error preparing read-request: %s", connectionResult.Err.Error())
main.go is in package main, not connector
