diff -u connector/plc4x.go.orig connector/plc4x.go
--- connector/plc4x.go.orig	2021-03-10 19:13:12.000000000 +0100
+++ connector/plc4x.go	2021-03-10 19:13:12.000000000 +0100
@@ -3,9 +3,9 @@
 import (
 	"context"
 	"encoding/json"
+	"flag"
 	"log"
 	"time"
-	"flag"
 
 	"github.com/nutanix/kps-connector-go-sdk/transport"
 
@@ -13,39 +13,36 @@
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/drivers"
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/model"
 	"github.com/apache/plc4x/plc4go/pkg/plc4go/transports"
-	
-	"net/http"
+
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promhttp"
+	"net/http"
 )
 
-
 type Address struct {
 	Name    string
 	Address string
 }
 
-type rvalue struct{
+type rvalue struct {
 	Field string `json:"field"`
 	Value string `json:"value"`
 }
 
-
 type streamMetadata struct {
 	Plc       string
 	Addresses []Address
 
-	
 	//PollingIntervall int  // removed for testing
 }
 
 var (
-	netBytes         = prometheus.NewCounter(prometheus.CounterOpts{
+	netBytes = prometheus.NewCounter(prometheus.CounterOpts{
 		Name: "network_bytes_total",
 		Help: "Number of bytes seen on the network.",
 	})
 
-	addr              = flag.String("listen-address", ":8080", "The address to listen on for HTTP requests.")
+	addr = flag.String("listen-address", ":8080", "The address to listen on for HTTP requests.")
 )
 
 // mapToStreamMetadata translates the stream metadata into the corresponding streamMetadata struct
@@ -71,26 +68,25 @@
 			// bail out
 		}
 		log.Printf("add Address: %s", addressAddress)
-		
+
 		addr := Address{
-			Name: addressName,
+			Name:    addressName,
 			Address: addressAddress,
 		}
 		addresses = append(addresses, addr)
 	}
 
-
 	return &streamMetadata{
-		Plc: plc,
-		Addresses: addresses,		
+		Plc:       plc,
+		Addresses: addresses,
 	}
 }
 
 type consumer struct {
 	transport  transport.Client
 	metadata   *streamMetadata
-	connection *plc4go.PlcConnection    //?????
-	rr         model.PlcReadRequest // ???? ReadRequest}
+	connection *plc4go.PlcConnection //?????
+	rr         model.PlcReadRequest  // ???? ReadRequest}
 }
 
 // producer consumes the data from the relevant client or service and publishes them to KPS data pipelines
@@ -103,11 +99,10 @@
 // from the relevant client or service
 func (c *consumer) nextMsg() ([]byte, error) {
 
-
 	netBytes.Add(float64(1))
 
 	// manual slow down Polling
-	time.Sleep(5 * time.Second )
+	time.Sleep(5 * time.Second)
 	rrc := c.rr.Execute()
 	log.Printf("nexmsg")
 	// Wait for the response to finish
@@ -118,32 +113,30 @@
 	}
 
 	// Do something with the response
-	
-	rvalues := make([]rvalue,0)
-	
+
+	rvalues := make([]rvalue, 0)
+
 	for _, fieldname := range rrr.Response.GetFieldNames() {
 		log.Printf("processing field: %s", fieldname)
 		if rrr.Response.GetResponseCode(fieldname) != model.PlcResponseCode_OK {
 			log.Printf("error an non-ok return code: %s", rrr.Response.GetResponseCode(fieldname).GetName())
 			return nil, nil
 		}
-	
+
 		value := rrr.Response.GetValue(fieldname)
 		log.Printf("Returned Value: %s", value.GetString())
-//
-		
+		//
+
 		toMarshal := rvalue{
 			Field: fieldname,
 			Value: value.GetString(),
 		}
-		
-//
-		rvalues = append(rvalues,toMarshal)
 
-		
+		//
+		rvalues = append(rvalues, toMarshal)
+
 	}
-	
-	
+
 	return json.Marshal(rvalues)
 
 }
@@ -165,7 +158,7 @@
 
 	// Get a connection to a remote PLC
 	crc := driverManager.GetConnection(metadata.Plc)
-	 // Wait for the driver to connect (or not)
+	// Wait for the driver to connect (or not)
 	connectionResult := <-crc
 	if connectionResult.Err != nil {
 		log.Printf("error connecting to PLC: %s", connectionResult.Err.Error())
@@ -184,7 +177,7 @@
 		log.Printf("added address: %s", address.Address)
 		rrb.AddItem(address.Name, address.Address)
 	}
-	
+
 	readRequest, err := rrb.Build()
 	if err != nil {
 		log.Printf("error preparing read-request: %s", connectionResult.Err.Error())
main.go is in package main, not connector
