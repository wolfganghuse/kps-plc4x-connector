diff -u connector/plc4x.go.orig connector/plc4x.go
--- connector/plc4x.go.orig	2021-03-05 21:47:56.000000000 +0100
+++ connector/plc4x.go	2021-03-05 21:47:56.000000000 +0100
@@ -22,7 +22,6 @@
 	Plc       string
 	Addresses []Address
 
-	
 	//PollingIntervall int  // removed for testing
 }
 
@@ -44,16 +43,15 @@
 		addressAddress := addressMap["address"]
 		log.Printf("add Address: %s", addressAddress)
 		addr := Address{
-			Name: addressName,
+			Name:    addressName,
 			Address: addressAddress,
 		}
 		addresses = append(addresses, addr)
 	}
 
-
 	return &streamMetadata{
-		Plc: plc,
-		Addresses: addresses,		
+		Plc:       plc,
+		Addresses: addresses,
 
 		// Same here, need to assign the struct here
 		// Addresses: {Name, Address}
@@ -64,8 +62,8 @@
 type consumer struct {
 	transport  transport.Client
 	metadata   *streamMetadata
-	connection *plc4go.PlcConnection    //?????
-	rr         model.PlcReadRequest // ???? ReadRequest}
+	connection *plc4go.PlcConnection //?????
+	rr         model.PlcReadRequest  // ???? ReadRequest}
 }
 
 // producer consumes the data from the relevant client or service and publishes them to KPS data pipelines
@@ -79,7 +77,7 @@
 func (c *consumer) nextMsg() ([]byte, error) {
 
 	// manual slow down Polling
-	time.Sleep(5 * time.Second )
+	time.Sleep(5 * time.Second)
 	rrc := c.rr.Execute()
 	log.Printf("nexmsg")
 	// Wait for the response to finish
@@ -91,7 +89,6 @@
 
 	// Do something with the response
 
-
 	if rrr.Response.GetResponseCode("field1") != model.PlcResponseCode_OK {
 		log.Printf("error an non-ok return code: %s", rrr.Response.GetResponseCode("field1").GetName())
 		return nil, nil
@@ -99,7 +96,7 @@
 
 	value := rrr.Response.GetValue("field1")
 	log.Printf("Returned Value: %s", value.GetString())
-	
+
 	return []byte(value.GetString()), nil // ???? TODO Typ-Conversion to Bytes missing
 }
 
@@ -113,7 +110,7 @@
 
 	// Get a connection to a remote PLC
 	crc := driverManager.GetConnection(metadata.Plc)
-	 // Wait for the driver to connect (or not)
+	// Wait for the driver to connect (or not)
 	connectionResult := <-crc
 	if connectionResult.Err != nil {
 		log.Printf("error connecting to PLC: %s", connectionResult.Err.Error())
@@ -133,7 +130,7 @@
 		rrb.AddItem(address.Name, address.Address)
 		//rrb.AddItem("field1","holding-register:4:INT")
 	}
-	
+
 	readRequest, err := rrb.Build()
 	if err != nil {
 		log.Printf("error preparing read-request: %s", connectionResult.Err.Error())
main.go is in package main, not connector
